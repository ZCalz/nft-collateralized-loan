/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
/// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract NFT is ERC721, Ownable {
    error NotOwner();

    struct vars0 {
        uint256 old_0;
    }

    uint256 public nextTokenId;
    string public baseURI = "https://tempory-uri.xyz/";

    constructor() ERC721("BasicNFT","NFT") {}

    function mint(address to) external returns (uint256 RET_0) {
        vars0 memory _v;
        unchecked {
            _v.old_0 = nextTokenId;
        }
        RET_0 = _original_NFT_mint(to);
        unchecked {
            if (!(nextTokenId == (_v.old_0 + 1))) {
                emit __ScribbleUtilsLib__2944.AssertionFailedData(0, abi.encode(nextTokenId));
                emit __ScribbleUtilsLib__2944.AssertionFailed("000913:0068:000 0: ");
            }
        }
    }

    function _original_NFT_mint(address to) internal returns (uint256) {
        _mint(to, nextTokenId);
        uint256 minted = nextTokenId;
        nextTokenId += 1;
        return minted;
    }

    function _baseURI() virtual override internal view returns (string memory) {
        return baseURI;
    }

    function setBaseURI(string memory newURI) external {
        _original_NFT_setBaseURI(newURI);
        unchecked {
            if (!(msg.sender == owner())) {
                emit __ScribbleUtilsLib__2944.AssertionFailed("001504:0068:000 1: ");
            }
            if (!(keccak256(bytes(baseURI)) == keccak256(bytes(newURI)))) {
                emit __ScribbleUtilsLib__2944.AssertionFailedData(2, abi.encode(baseURI, newURI));
                emit __ScribbleUtilsLib__2944.AssertionFailed("001779:0068:000 2: ");
            }
        }
    }

    function _original_NFT_setBaseURI(string memory newURI) internal {
        if (msg.sender != owner()) revert NotOwner();
        baseURI = newURI;
    }
}

library __ScribbleUtilsLib__2944 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}